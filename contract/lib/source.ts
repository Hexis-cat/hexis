export const source = {
  language: 'Solidity',
  sources: {
    '@openzeppelin/contracts/access/Ownable.sol': {
      content:
        '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from "../utils/Context.sol";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n',
    },
    '@openzeppelin/contracts/token/ERC20/IERC20.sol': {
      content:
        "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n",
    },
    '@openzeppelin/contracts/utils/Context.sol': {
      content:
        '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n',
    },
    'contracts/HexisBooth.sol': {
      content:
        '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\n// HexisBooth Contract\n// Users own and sell content, managing their earnings.\ncontract HexisBooth is Ownable {\n    // Address to receive fees (hardcoded)\n    address public immutable FEE_RECEIVER = 0x9398084E888CB5B5c126240439054b57C10138E7;\n\n    // --- Enum Definitions ---\n    enum SaleType {\n        InstantSale, // Available for immediate purchase\n        RequestSale  // Requires a purchase request\n    }\n\n    enum PaymentOption {\n        NativeCurrency, // ETH or the chain\'s native currency\n        ERC20Token      // A specific ERC20 token\n    }\n\n    // --- State Variables ---\n    string public previewText; // Public preview text\n    uint256 public price; // Content price\n    address public paymentTokenAddress; // ERC20 token address for payment (address(0) if PaymentOption.NativeCurrency)\n    PaymentOption public currentPaymentOption; // Current payment option (changed to enum)\n\n    bool public saleStarted; // Indicates if the sale has started\n    SaleType public currentSaleType; // Current sale type\n\n    // Content purchasers (mapping: buyer address => purchase status/approval status)\n    mapping(address => bool) public hasAccess;\n    mapping(address => bool) public hasRequested;\n    mapping(address => bool) public isApprovedToBuy;\n\n    // Withdrawable balance (after fee calculation)\n    mapping(address => uint256) public withdrawableBalance;\n\n    // --- Events ---\n    event PreviewTextUpdated(string newPreviewText);\n    event PriceUpdated(uint256 newPrice);\n    event SaleStarted(SaleType saleType);\n    event ContentPurchased(address indexed buyer, uint256 amountPaid, address indexed tokenAddress, PaymentOption paymentOption, SaleType saleType); // Changed event arguments\n    event PurchaseRequested(address indexed requester, string contactInfo);\n    event RequestApproved(address indexed requester);\n    event FundsCheckedOut(address indexed owner, uint256 grossAmount, uint256 feeAmount, uint256 netAmount, PaymentOption paymentOption); // Changed event arguments\n    event FundsWithdrawn(address indexed owner, uint256 amount, PaymentOption paymentOption); // Changed event arguments\n\n    // --- Constructor ---\n    constructor(\n        address ownerAddress,\n        string memory _previewText,\n        uint256 _price,\n        PaymentOption _paymentOption, // Changed to PaymentOption enum\n        address _paymentTokenAddress, // Token address if ERC20\n        SaleType _saleType\n    ) Ownable(ownerAddress) {\n        // Validate payment option\n        if (_paymentOption == PaymentOption.NativeCurrency) {\n            require(_paymentTokenAddress == address(0), "ERC20 token address must be zero for NativeCurrency.");\n        } else if (_paymentOption == PaymentOption.ERC20Token) {\n            require(_paymentTokenAddress != address(0), "ERC20 token address cannot be zero for ERC20Token.");\n        }\n\n        previewText = _previewText;\n        price = _price;\n        currentPaymentOption = _paymentOption;\n        paymentTokenAddress = _paymentTokenAddress;\n        currentSaleType = _saleType;\n        saleStarted = false;\n    }\n\n    // --- Seller (Owner) Functions ---\n\n    function updatePreviewText(string memory _newPreviewText) public onlyOwner {\n        require(!saleStarted, "Sale has already started.");\n        previewText = _newPreviewText;\n        emit PreviewTextUpdated(_newPreviewText);\n    }\n\n    function updatePrice(uint256 _newPrice) public onlyOwner {\n        require(!saleStarted, "Sale has already started.");\n        price = _newPrice;\n        emit PriceUpdated(_newPrice);\n    }\n\n    function startSale() public onlyOwner {\n        require(!saleStarted, "Sale already started.");\n        saleStarted = true;\n        emit SaleStarted(currentSaleType);\n    }\n\n    function approveRequest(address _requester) public onlyOwner {\n        require(saleStarted, "Sale has not started.");\n        require(currentSaleType == SaleType.RequestSale, "This is not a request sale type.");\n        require(hasRequested[_requester], "No purchase request from this address.");\n        require(!isApprovedToBuy[_requester], "Request already approved.");\n\n        isApprovedToBuy[_requester] = true;\n        emit RequestApproved(_requester);\n    }\n\n    // --- Buyer/User Functions ---\n\n    // Common purchase logic (internal helper)\n    function _processPurchase(address buyer) internal {\n        if (currentPaymentOption == PaymentOption.NativeCurrency) {\n            require(msg.value == price, "Incorrect Native Currency amount sent.");\n            // Native Currency is automatically transferred to the contract address.\n        } else { // ERC20Token\n            require(msg.value == 0, "Do not send Native Currency with ERC20 payment.");\n            IERC20 token = IERC20(paymentTokenAddress);\n            require(token.transferFrom(buyer, address(this), price), "ERC20 Token transfer failed. Check allowance.");\n        }\n        hasAccess[buyer] = true;\n    }\n\n    // Buys content and gains access in instant sale type.\n    function buyInstant() public payable {\n        require(saleStarted, "Sale has not started.");\n        require(currentSaleType == SaleType.InstantSale, "This is not an instant sale type. Use requestPurchase().");\n        require(!hasAccess[_msgSender()], "You already have access.");\n\n        _processPurchase(_msgSender());\n        emit ContentPurchased(_msgSender(), price, paymentTokenAddress, currentPaymentOption, currentSaleType);\n    }\n\n    // Sends a purchase request in request sale type.\n    function requestPurchase(string memory _contactInfo) public {\n        require(saleStarted, "Sale has not started.");\n        require(currentSaleType == SaleType.RequestSale, "This is not a request sale type. Use buyInstant().");\n        require(!hasRequested[_msgSender()], "You have already requested purchase.");\n\n        hasRequested[_msgSender()] = true;\n        emit PurchaseRequested(_msgSender(), _contactInfo);\n    }\n\n    // Buys content and gains access after approval in request sale type.\n    function buyApproved() public payable {\n        require(saleStarted, "Sale has not started.");\n        require(currentSaleType == SaleType.RequestSale, "This is not a request sale type.");\n        require(isApprovedToBuy[_msgSender()], "Your purchase request has not been approved yet.");\n        require(!hasAccess[_msgSender()], "You already have access.");\n\n        _processPurchase(_msgSender());\n        emit ContentPurchased(_msgSender(), price, paymentTokenAddress, currentPaymentOption, currentSaleType);\n    }\n\n    // --- Settlement and Withdrawal ---\n\n    // Calculates sales and fees, then updates the withdrawable balance.\n    function checkOut() public onlyOwner {\n        uint256 totalBalance;\n        if (currentPaymentOption == PaymentOption.NativeCurrency) {\n            totalBalance = address(this).balance;\n        } else { // ERC20Token\n            totalBalance = IERC20(paymentTokenAddress).balanceOf(address(this));\n        }\n\n        require(totalBalance > 0, "No funds to checkout.");\n\n        uint256 feeAmount = (totalBalance * 2) / 100; // 2% fee\n        uint256 netAmount = totalBalance - feeAmount;\n\n        withdrawableBalance[_msgSender()] += netAmount;\n\n        if (currentPaymentOption == PaymentOption.NativeCurrency) {\n            payable(FEE_RECEIVER).transfer(feeAmount);\n        } else {\n            IERC20(paymentTokenAddress).transfer(FEE_RECEIVER, feeAmount);\n        }\n\n        emit FundsCheckedOut(_msgSender(), totalBalance, feeAmount, netAmount, currentPaymentOption);\n    }\n\n    // Withdraws the checked-out amount.\n    function withdraw() public onlyOwner {\n        uint256 amount = withdrawableBalance[_msgSender()];\n        require(amount > 0, "No withdrawable balance.");\n\n        withdrawableBalance[_msgSender()] = 0;\n\n        if (currentPaymentOption == PaymentOption.NativeCurrency) {\n            (bool success, ) = payable(_msgSender()).call{value: amount}("");\n            require(success, "Native Currency transfer failed.");\n        } else {\n            require(IERC20(paymentTokenAddress).transfer(_msgSender(), amount), "ERC20 Token transfer failed.");\n        }\n\n        emit FundsWithdrawn(_msgSender(), amount, currentPaymentOption);\n    }\n}\n\n',
    },
    'contracts/HexisFactory.sol': {
      content:
        '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport "./HexisBooth.sol";\n\ncontract HexisFactory {\n    // Events\n    event BoothCreated(address indexed boothAddress, address indexed owner);\n\n    // Counts\n    uint256 public boothCount;\n\n    // Create a new HexisBooth contract\n    function createHexisBooth(\n        address ownerAddress,\n        string memory previewText,\n        uint256 price,\n        HexisBooth.PaymentOption paymentOption,\n        address paymentTokenAddress,\n        HexisBooth.SaleType saleType\n    ) public returns (HexisBooth) {\n        HexisBooth newBooth = new HexisBooth(\n            ownerAddress,\n            previewText,\n            price,\n            paymentOption,\n            paymentTokenAddress,\n            saleType\n        );\n        emit BoothCreated(address(newBooth), ownerAddress);\n        boothCount++;\n        return newBooth;\n    }\n    \n}',
    },
  },
  settings: {
    evmVersion: 'paris',
    optimizer: {
      enabled: false,
      runs: 200,
    },
    outputSelection: {
      '*': {
        '*': [
          'abi',
          'evm.bytecode',
          'evm.deployedBytecode',
          'evm.methodIdentifiers',
          'metadata',
          'devdoc',
          'userdoc',
          'storageLayout',
          'evm.gasEstimates',
        ],
        '': ['ast'],
      },
    },
    metadata: {
      useLiteralContent: true,
    },
  },
};
